'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(stream, err, cb) { // <-- Add 'stream' parameter here
  var _this = this;
  var readableDestroyed = stream._readableState && stream._readableState.destroyed; // <-- Change 'this' to 'stream'
  var writableDestroyed = stream._writableState && stream._writableState.destroyed; // <-- Change 'this' to 'stream'
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (stream._readableState) {
    stream._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (stream._writableState) {
    stream._writableState.destroyed = true;
  }
this._destroy(err || null, function (err) {
  if (!cb && err) {
    if (!stream._writableState) {
      process.nextTick(emitErrorAndCloseNT, stream, err);
    } else if (!stream._writableState.errorEmitted) {
      stream._writableState.errorEmitted = true;
      process.nextTick(emitErrorAndCloseNT, stream, err);
    } else {
      process.nextTick(emitCloseNT, stream);
    }
  } else if (cb) {
    process.nextTick(emitCloseNT, stream);
    cb(err);
  } else {
    process.nextTick(emitCloseNT, stream);
  }
});
return stream;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy(stream) { // <-- Add 'stream' parameter here
  if (stream._readableState) {
    stream._readableState.destroyed = false;
    stream._readableState.reading = false;
    stream._readableState.ended = false;
    stream._readableState.endEmitted = false;
  }

  if (stream._writableState) {
    stream._writableState.destroyed = false;
    stream._writableState.ended = false;
    stream._writableState.ending = false;
    stream._writableState.finalCalled = false;
    stream._writableState.prefinished = false;
    stream._writableState.finished = false;
    stream._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
